#!/usr/bin/env python3
# -*- encoding: utf-8 -*-
#

import re
import sys
import time
from array import array
from datetime import datetime
from typing import List, Optional

import typer


class SimpleTextAndIcons:
    font_11x44 = (
        # 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
        0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0xfc, 0x00,
        0x00, 0x7c, 0xc6, 0xc6, 0xc0, 0xc0, 0xc0, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0xfc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xfc, 0x00,
        0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xfe, 0x00,
        0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xf0, 0x00,
        0x00, 0x7c, 0xc6, 0xc6, 0xc0, 0xc0, 0xce, 0xc6, 0xc6, 0x7e, 0x00,
        0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
        0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
        0x00, 0xe6, 0x66, 0x6c, 0x6c, 0x78, 0x6c, 0x6c, 0x66, 0xe6, 0x00,
        0x00, 0xf0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
        0x00, 0x82, 0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
        0x00, 0x86, 0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0x00,
        0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0xf0, 0x00,
        0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xde, 0x7c, 0x06,
        0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0xe6, 0x00,
        0x00, 0x7c, 0xc6, 0xc6, 0x60, 0x38, 0x0c, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0x7e, 0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00,
        0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x82, 0x00,
        0x00, 0xc6, 0xc6, 0x6c, 0x7c, 0x38, 0x7c, 0x6c, 0xc6, 0xc6, 0x00,
        0x00, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0xfe, 0xc6, 0x86, 0x0c, 0x18, 0x30, 0x62, 0xc6, 0xfe, 0x00,

        # 'abcdefghijklmnopqrstuvwxyz'
        0x00, 0x00, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
        0x00, 0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x00,
        0x00, 0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
        0x00, 0x1c, 0x36, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xcc, 0x78,
        0x00, 0xe0, 0x60, 0x60, 0x6c, 0x76, 0x66, 0x66, 0x66, 0xe6, 0x00,
        0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
        0x0c, 0x0c, 0x00, 0x1c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
        0x00, 0xe0, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0xe6, 0x00,
        0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xec, 0xfe, 0xd6, 0xd6, 0xd6, 0xc6, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0,
        0x00, 0x00, 0x00, 0x00, 0x7c, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c, 0x1e,
        0x00, 0x00, 0x00, 0x00, 0xde, 0x76, 0x60, 0x60, 0x60, 0xf0, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x70, 0x1c, 0xc6, 0x7c, 0x00,
        0x00, 0x10, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x34, 0x18, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xc6, 0xd6, 0xd6, 0xd6, 0xfe, 0x6c, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0xf8,
        0x00, 0x00, 0x00, 0x00, 0xfe, 0x8c, 0x18, 0x30, 0x62, 0xfe, 0x00,

        # '0987654321^ !"\0$%&/()=?` °\\}][{'
        0x00, 0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0xc6, 0x7c, 0x00,
        0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0xfe, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00,
        0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0xfe, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0x06, 0xc6, 0x7c, 0x00,
        0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x1e, 0x00,
        0x00, 0x7c, 0xc6, 0x06, 0x06, 0x3c, 0x06, 0x06, 0xc6, 0x7c, 0x00,
        0x00, 0x7c, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00,
        0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00,
        0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3c, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00,
        0x66, 0x66, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x7c, 0x04, 0x14, 0x18, 0x10, 0x10, 0x20,
        0x10, 0x7c, 0xd6, 0xd6, 0x70, 0x1c, 0xd6, 0xd6, 0x7c, 0x10, 0x10,
        0x00, 0x60, 0x92, 0x96, 0x6c, 0x10, 0x6c, 0xd2, 0x92, 0x0c, 0x00,
        0x00, 0x38, 0x6c, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0xcc, 0x76, 0x00,
        0x00, 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
        0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00,
        0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00,
        0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x7c, 0xc6, 0xc6, 0x0c, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00,
        0x18, 0x18, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c,
        0x00, 0x10, 0x28, 0x28, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x80, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00, 0x00,
        0x00, 0x70, 0x18, 0x18, 0x18, 0x0e, 0x18, 0x18, 0x18, 0x70, 0x00,
        0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00,
        0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00,
        0x00, 0x0e, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x0e, 0x00,

        # "@ ~ |<>,;.:-_#'+* "
        0x00, 0x00, 0x3c, 0x42, 0x9d, 0xa5, 0xad, 0xb6, 0x40, 0x3c, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0x00, 0x00, 0x00,
        0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x08, 0x08, 0x7c, 0x08, 0x08, 0x18, 0x18, 0x28, 0x28, 0x48, 0x18,
        0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00,
        0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x10, 0x20,
        0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x08, 0x10,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
        0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x00, 0x00,
        0x18, 0x18, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        # "äöüÄÖÜß"
        0x00, 0xcc, 0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
        0x00, 0xc6, 0xc6, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0xcc, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
        0xc6, 0xc6, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
        0xc6, 0xc6, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0xc6, 0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0x3c, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0x6c, 0x60,

        # "àäòöùüèéêëôöûîïÿç"
        0x00, 0x60, 0x18, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
        0x00, 0x6c, 0x6c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
        0x00, 0x60, 0x18, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0x6c, 0x6c, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0x60, 0x18, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
        0x00, 0x6c, 0x6c, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
        0x00, 0x60, 0x18, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
        0x00, 0x18, 0x60, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
        0x00, 0x10, 0x6c, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
        0x00, 0x6c, 0x6c, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
        0x00, 0x10, 0x6c, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0x6c, 0x6c, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
        0x00, 0x10, 0x6c, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
        0x00, 0x10, 0x6c, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0x6c, 0x6c, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0x6c, 0x6c, 0x00, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0xf8,
        0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x10, 0x30,

        # "ÀÅÄÉÈÊËÖÔÜÛÙŸ"
        0x60, 0x18, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
        0x10, 0x6c, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
        0x6c, 0x6c, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,
        0x18, 0x60, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xfe, 0x00,
        0x60, 0x18, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xfe, 0x00,
        0x10, 0x6c, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xfe, 0x00,
        0x6c, 0x6c, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xfe, 0x00,
        0x6c, 0x6c, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  # Ö
        0x10, 0x6c, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  # Ô
        0x6c, 0x6c, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  # Ü
        0x10, 0x6c, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  # Û
        0x60, 0x18, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  # Ù
        0x66, 0x66, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x3c, 0x00,  # Ÿ
    )

    charmap = u'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + \
              u'abcdefghijklmnopqrstuvwxyz' + \
              u'0987654321^ !"\0$%&/()=?` °\\}][{' + \
              u"@ ~ |<>,;.:-_#'+* " + \
              u"äöüÄÖÜß" + \
              u"àäòöùüèéêëôöûîïÿç" + \
              u"ÀÅÄÉÈÊËÖÔÜÛÙŸ"

    char_offsets = {}
    for i in range(len(charmap)):
        char_offsets[charmap[i]] = 11 * i
        # print(i, charmap[i], char_offsets[charmap[i]])

    bitmap_named = {
        'ball':      (array('B', (
            0b00000000,
            0b00000000,
            0b00111100,
            0b01111110,
            0b11111111,
            0b11111111,
            0b11111111,
            0b11111111,
            0b01111110,
            0b00111100,
            0b00000000
        )), 1, '\x1e'),
    }

    bitmap_builtin = {}
    for i in bitmap_named:
        bitmap_builtin[bitmap_named[i][2]] = bitmap_named[i]

    def __init__(self):
        self.bitmap_preloaded = [([], 0)]
        self.bitmaps_preloaded_unused = False

    def add_preload_img(self, filename):
        """Still used by main, but deprecated. PLease use ":"-notation for bitmap() / bitmap_text()"""
        self.bitmap_preloaded.append(SimpleTextAndIcons.bitmap_img(filename))
        self.bitmaps_preloaded_unused = True

    def are_preloaded_unused(self):
        """Still used by main, but deprecated. PLease use ":"-notation for bitmap() / bitmap_text()"""
        return self.bitmaps_preloaded_unused is True

    @staticmethod
    def _get_named_bitmaps_keys():
        return SimpleTextAndIcons.bitmap_named.keys()

    def bitmap_char(self, ch):
        """Returns a tuple of 11 bytes, it is the bitmap data of given character.
            Example: ch = '_' returns (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255).
            The bits in each byte are horizontal, highest bit is left.
        """
        if ord(ch) < 32:
            if ch in SimpleTextAndIcons.bitmap_builtin:
                return SimpleTextAndIcons.bitmap_builtin[ch][:2]

            self.bitmaps_preloaded_unused = False
            return self.bitmap_preloaded[ord(ch)]

        o = SimpleTextAndIcons.char_offsets[ch]
        return SimpleTextAndIcons.font_11x44[o:o + 11], 1

    def bitmap_text(self, text):
        """Returns a tuple of (buffer, length_in_byte_columns_aka_chars)
          We preprocess the text string for substitution patterns
          "::" is replaced with a single ":"
          ":1: is replaced with CTRL-A referencing the first preloaded or loaded image.
          ":happy:" is replaced with a reference to a builtin smiley glyph
          ":ball:" is replaced with a reference to a builtin ball glyph
          ":gfx/logo.png:" preloads the file gfx/logo.png and is replaced the corresponding control char.
        """

        def replace_symbolic(m):
            name = m.group(1)
            if name == '':
                return ':'
            if re.match('^[0-9]*$', name):  # py3 name.isdecimal()
                return chr(int(name))
            if '.' in name:
                self.bitmap_preloaded.append(SimpleTextAndIcons.bitmap_img(name))
                return chr(len(self.bitmap_preloaded) - 1)
            return SimpleTextAndIcons.bitmap_named[name][2]

        text = re.sub(r':([^:]*):', replace_symbolic, text)
        buf = array('B')
        cols = 0
        for c in text:
            (b, n) = self.bitmap_char(c)
            buf.extend(b)
            cols += n
        return buf, cols

    def bitmap(self, arg):
        """If arg is a valid and existing path name, we load it as an image.
            Otherwise, we take it as a string (with ":"-notation, see bitmap_text()).
        """
        return self.bitmap_text(arg)


class WriteLibUsb():
    """Write to a device using pyusb and libusb. The device ids consist of the bus number, the device number on that bus
    and the endpoint number.
    """
    _module_loaded = False
    try:
        import usb.core
        import usb.util
        _module_loaded = True
        print("Module usb.core detected")
    except:
        pass

    def __init__(self):
        self.devices = {}
        self.description = None
        self.dev = None
        self.endpoint = None

    def get_name(self):
        return 'libusb'

    def get_description(self):
        return 'Program a device connected via USB using the pyusb package and libusb.'

    def open(self, device_id):
        """Opens the communication channel to the device, similar to open a file. The device id is one of the ids
        returned by get_available_devices() or 'auto', which selects just the first device in that dict.
        It is the common part of the opening process. The concrete open is done in _open() and is to be implemented
        individually.
        """
        if self.is_ready() and self.is_device_present():
            actual_device_id = None
            if device_id == 'auto':
                actual_device_id = sorted(self.devices.keys())[0]
            else:
                if device_id in self.devices.keys():
                    actual_device_id = device_id

            if actual_device_id:
                return self._open(actual_device_id)
        return False

    def is_device_present(self):
        """Returns True if there is one or more devices available via the concrete write method, False otherwise.
        """
        self.get_available_devices()
        return self.devices and len(self.devices) > 0

    def _open(self, device_id):
        self.description = self.devices[device_id][0]
        self.dev = self.devices[device_id][1]
        self.endpoint = self.devices[device_id][2]
        print("Libusb device initialized")
        return True

    @staticmethod
    def add_padding(buf, block_size):
        """The given data array will be extended with zeros according to the given block size. SO, afterwards the
        length of the array is a multiple of block_size.
        """
        need_padding = len(buf) % block_size
        if need_padding:
            buf.extend((0,) * (block_size - need_padding))

    @staticmethod
    def check_length(buf, max_size):
        """Just checks the length of the given data array and abort the program execution if it exceeds max_size.
        """
        if len(buf) > max_size:
            print("Writing more than %d bytes damages the display! Nothing written." % (max_size,))
            sys.exit(1)

    def close(self):
        if self.dev:
            self.dev.reset()
            WriteLibUsb.usb.util.dispose_resources(self.dev)
        self.description = None
        self.dev = None
        self.endpoint = None

    def write(self, buf):
        """Call this to write data to the opened device.
        The concrete write action is to be implemented in _write()."""
        self.add_padding(buf, 64)
        self.check_length(buf, 8192)
        self._write(buf)

    def get_available_devices(self):
        """Get all devices available via the concrete write method. It returns a dict with the device ids as keys
        and the device descriptions as values. These device ids are used with 'open()' to specify the wanted device.
        It the common part of this process. The concrete part is to be implemented in _get_available_devices()
        individually.
        """
        if self.is_ready() and not self.devices:
            self.devices = self._get_available_devices()
        return {did: data[0] for did, data in self.devices.items()}

    def _get_available_devices(self):
        devs = WriteLibUsb.usb.core.find(idVendor=0x0416, idProduct=0x5020, find_all=True)
        devices = {}
        for d in devs:
            try:
                # win32: NotImplementedError: is_kernel_driver_active
                if d.is_kernel_driver_active(0):
                    d.detach_kernel_driver(0)
            except:
                pass
            try:
                d.set_configuration()
            except WriteLibUsb.usb.core.USBError:
                # TODO: use all the nice output in _find_write_method(), somehow.
                print("No read access to device list!")
                LedNameBadge._print_sudo_hints()
                sys.exit(1)

            cfg = d.get_active_configuration()[0, 0]
            eps = WriteLibUsb.usb.util.find_descriptor(
                cfg,
                find_all=True,
                custom_match=lambda e: WriteLibUsb.usb.util.endpoint_direction(e.bEndpointAddress) == WriteLibUsb.usb.util.ENDPOINT_OUT)
            for ep in eps:
                did = "%d:%d:%d" % (d.bus, d.address, ep.bEndpointAddress)
                descr = ("%s - %s (bus=%d dev=%d endpoint=%d)" %
                         (d.manufacturer, d.product, d.bus, d.address, ep.bEndpointAddress))
                devices[did] = (descr, d, ep)
        return devices

    def is_ready(self):
        return WriteLibUsb._module_loaded

    def has_device(self):
        return self.dev is not None

    def _write(self, buf):
        if not self.dev:
            return

        try:
            # win32: NotImplementedError: is_kernel_driver_active
            if self.dev.is_kernel_driver_active(0):
                self.dev.detach_kernel_driver(0)
        except:
            pass

        try:
            self.dev.set_configuration()
        except WriteLibUsb.usb.core.USBError:
            # TODO: use all the nice output in _find_write_method(), somehow.
            print("No write access to device!")
            LedNameBadge._print_sudo_hints()
            sys.exit(1)

        print("Write using %s via libusb" % (self.description,))
        for i in range(int(len(buf) / 64)):
            time.sleep(0.1)
            self.endpoint.write(buf[i * 64:i * 64 + 64])


class LedNameBadge:
    _protocol_header_template = (
        0x77, 0x61, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    )

    @staticmethod
    def header(lengths, speeds, modes, blinks, ants, brightness=100, date=datetime.now()):
        """Create a protocol header
            * length, speeds, modes, blinks, ants are iterables with at least one element
            * lengths[0] is the number of chars/byte-columns of the first text/bitmap, lengths[1] of the second,
              and so on...
            * len(length) should match the designated bitmap data
            * speeds come in as 1..8, but will be decremented to 0..7, here.
            * modes: 0..8
            * blinks and ants: 0..1 or even False...True,
            * brightness, if given, is any number, but it'll be limited to 25, 50, 75, 100 (percent), here
            * date, if given, is a datetime object. It will be written in the header, but is not to be seen on the
              devices screen.
        """
        try:
            lengths_sum = sum(lengths)
        except:
            raise TypeError("Please give a list or tuple with at least one number: " + str(lengths))
        if lengths_sum > (8192 - len(LedNameBadge._protocol_header_template)) / 11 + 1:
            raise ValueError("The given lengths seem to be far too high: " + str(lengths))

        ants = LedNameBadge._prepare_iterable(ants, 0, 1)
        blinks = LedNameBadge._prepare_iterable(blinks, 0, 1)
        speeds = LedNameBadge._prepare_iterable(speeds, 1, 8)
        modes = LedNameBadge._prepare_iterable(modes, 0, 8)

        speeds = [x - 1 for x in speeds]

        h = list(LedNameBadge._protocol_header_template)

        if brightness <= 25:
            h[5] = 0x40
        elif brightness <= 50:
            h[5] = 0x20
        elif brightness <= 75:
            h[5] = 0x10
        # else default 100% == 0x00

        for i in range(8):
            h[6] += blinks[i] << i
            h[7] += ants[i] << i

        for i in range(8):
            h[8 + i] = 16 * speeds[i] + modes[i]

        for i in range(len(lengths)):
            h[17 + (2 * i) - 1] = lengths[i] // 256
            h[17 + (2 * i)] = lengths[i] % 256

        try:
            h[38 + 0] = date.year % 100
            h[38 + 1] = date.month
            h[38 + 2] = date.day
            h[38 + 3] = date.hour
            h[38 + 4] = date.minute
            h[38 + 5] = date.second
        except:
            raise TypeError("Please give a datetime object: " + str(date))

        return h

    @staticmethod
    def _prepare_iterable(iterable, min_, max_):
        try:
            iterable = [min(max(x, min_), max_) for x in iterable]
            iterable = tuple(iterable) + (iterable[-1],) * (8 - len(iterable))  # repeat last element
            return iterable
        except:
            raise TypeError("Please give a list or tuple with at least one number: " + str(iterable))

    @staticmethod
    def write(buf):
        """Write the given buffer to the given device.
            It has to begin with a protocol header as provided by header() and followed by the bitmap data.
            In short: the bitmap data is organized in bytes with 8 horizontal pixels per byte and 11 resp. 12
            bytes per (8 pixels wide) byte-column. Then just put one byte-column after the other and one bitmap
            after the other.
            The two optional parameters specify the write method and device, which shall be programmed. See
            get_available_methods() and get_available_device_ids(). There are two special values each: 'list'
            will print the implemented / available write methods resp. the available devices, 'auto' (default) will
            choose an appropriate write method resp. the first device found.
        """
        write_method = WriteLibUsb()
        write_method.open('auto')
        write_method.write(buf)
        write_method.close()


def main(
    message: List[str] = typer.Argument(
        None,
        help="Up to 8 message texts with embedded builtin icons or loaded images within colons(:)"
    ),
    speed: str = typer.Option(
        "4", 
        "--speed", 
        "-s",
        help="Scroll speed (Range 1..8). Up to 8 comma-separated values."
    ),
    brightness: int = typer.Option(
        100, 
        "--brightness", 
        "-B",
        help="Brightness for the display in percent: 25, 50, 75, or 100."
    ),
    mode: str = typer.Option(
        "0", 
        "--mode", 
        "-m",
        help="Up to 8 mode values: Scroll-left(0) -right(1) -up(2) -down(3); still-centered(4); animation(5); drop-down(6); curtain(7); laser(8)"
    ),
    blink: str = typer.Option(
        "0", 
        "--blink", 
        "-b",
        help="1: blinking, 0: normal. Up to 8 comma-separated values."
    ),
    ants: str = typer.Option(
        "0", 
        "--ants", 
        "-a",
        help="1: animated border, 0: normal. Up to 8 comma-separated values."
    ),
    preload: Optional[List[str]] = typer.Option(
        None, 
        "--preload", 
        "-p",
        help="Load bitmap images (deprecated, embed within ':' instead)"
    ),
    list_icons: bool = typer.Option(
        False,
        "--list-icons",
        "-l",
        help="List named icons to be embedded in messages and exit"
    ),
) -> None:
    """Upload messages or graphics to a 11x44 LED badge via USB.
    
    Example combining image and text: led-fun 'I:ball:you'
    """
    if list_icons:
        icons = SimpleTextAndIcons._get_named_bitmaps_keys()
        typer.echo("Available named icons:")
        typer.echo(":" + ":  :".join(icons) + ":")
        typer.echo("\nOr use custom images: :path/to/some_icon.png:")
        raise typer.Exit()
    
    if not message:
        typer.echo("Error: Missing required argument 'MESSAGE'.")
        typer.echo("Try 'led-fun --help' for help.")
        raise typer.Exit(1)
    
    creator = SimpleTextAndIcons()

    if preload:
        for filename in preload:
            creator.add_preload_img(filename)

    msg_bitmaps = []
    for msg_arg in message:
        msg_bitmaps.append(creator.bitmap(msg_arg))

    lengths = [b[1] for b in msg_bitmaps]
    speeds = split_to_ints(speed)
    modes = split_to_ints(mode)
    blinks = split_to_ints(blink)
    ants_vals = split_to_ints(ants)

    buf = array('B')
    buf.extend(LedNameBadge.header(lengths, speeds, modes, blinks, ants_vals, brightness))

    for msg_bitmap in msg_bitmaps:
        buf.extend(msg_bitmap[0])

    LedNameBadge.write(buf)


def split_to_ints(list_str: str) -> List[int]:
    """Split a comma or space-separated string into a list of integers."""
    return [int(x) for x in re.split(r'[\s,]+', list_str)]


def cli_entry() -> None:
    """Entry point for the CLI."""
    typer.run(main)


if __name__ == '__main__':
    cli_entry()
